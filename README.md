# Marketing

## Описание проекта

Интернет-магазин собирает историю покупателей, проводит рассылки предложений и планирует будущие продажи. Для оптимизации процессов надо выделить пользователей, которые готовы совершить покупку в ближайшее время.

### Цель

Предсказать вероятность покупки в течение 90 дней.

### Задачи

- Изучить данные
- Разработать полезные признаки
- Создать модель для классификации пользователей
- Улучшить модель и максимизировать метрику roc_auc
- Выполнить тестирование

## Описание данных

### `apparel-purchases`

Данные о покупках клиентов по дням и по товарам. В каждой записи покупка определенного товара, его цена, количество штук.

В таблице есть списки идентификаторов, к каким категориям относится товар. Часто это вложенные категории (например автотовары-аксессуары-освежители), но также может включать в начале списка маркер распродажи или маркер женщинам/мужчинам.

Нумерация категорий сквозная для всех уровней, то есть 44 на второй позиции списка или на третьей – это одна и та же категория. Иногда дерево категорий обновляется, поэтому могут меняться вложенности, например `['4', '28', '44', '1594']` или `['4', '44', '1594']`.

- `client_id` — идентификатор клиента,
- `quantity` — количество единиц товара,
- `price` — цена товара,
- `category_ids` — идентификаторы категорий,
- `date` — дата покупки,
- `message_id` — идентификатор сообщения из рассылки.

### `apparel-messages`

Рассылки, которые были отправлены клиентам из таблицы покупок.

- `bulk_campaign_id` — идентификатор рассылки,
- `client_id` — идентификатор клиента,
- `message_id` — идентификатор сообщения,
- `event` — действие с сообщением (отправлено, открыто, покупка …),
- `channel` — канал рассылки,
- `date` — дата действия,
- `created_at` — точное время создания сообщения.

### `target`

- `client_id` — идентификатор клиента,
- `target` — клиент совершил повторную покупку в целевом периоде.

## Загрузка данных

### `apparel-purchases`

Создан датафрейм `apparel_purchases`, содержащий в себе данные о покупках клиентов по дням и по товарам. Он имеет 6 столбцов и 202 208 строк. При этом столбцы имеют следующий характер:

- `client_id` — идентификатор клиента. Имеет тип `int64`;
- `quantity` — количество единиц товара. Имеет тип `int64`, а значения распределены от 1 до 30. При этом среднее значение составляет примерно 1.006, а медиана — 1;
- `price` — цена товара. Имеет тип `float64`, а значения распределены от 1 до 85 499. При этом среднее значение составляет примерно 1193.301, а медиана — 987;
- `category_ids` — идентификаторы категорий. Имеет тип `object` и 933 уникальных значения. При этом наиболее часто встречающиеся значение `['4', '28', '57', '431']` (встречается 8 626 раз);
- `date` — дата покупки. Имеет тип `object` и 642 уникальных значения. При этом наиболее часто встречающиеся значение `2022-11-11` (встречается 5 270 раз);
- `message_id` — идентификатор сообщения из рассылки. Имеет тип `object` и 50 204 уникальных значения. При этом наиболее часто встречающиеся значение `1515915625489095763-6251-6311b13a4cf78` (встречается 365 раз).

### `apparel-messages`

Создан датафрейм `apparel_messages`, содержащий в себе данные о рассылках, которые были отправлены клиентам из таблицы покупок. Он имеет 7 столбцов и 12 739 798 строк. При этом столбцы имеют следующий характер:

- `bulk_campaign_id` — идентификатор рассылки. Имеет тип `int64`;
- `client_id` — идентификатор клиента. Имеет тип `int64`;
- `message_id` — идентификатор сообщения. Имеет тип `object`и 9 061 667 уникальных значений. При этом наиболее часто встречающиеся значение `1515915625489095763-6251-6311b13a4cf78` (встречается 1 454 раза);
- `event` — действие с сообщением (отправлено, открыто, покупка …). Имеет тип `object`и 11 уникальных значений. При этом наиболее часто встречающиеся значение `send` (встречается 9 058 196 раз);
- `channel` — канал рассылки. Имеет тип `object` и 2 уникальных значения. При этом наиболее часто встречающиеся значение `mobile_push` (встречается 7 512 156 раз);
- `date` — дата действия. Имеет тип `object` и 638 уникальных значений. При этом наиболее часто встречающиеся значение `2023-06-10` (встречается 89 661 раз);
- `created_at` — точное время создания сообщения. Имеет тип `object` и 4 103 539 уникальных значений. При этом наиболее часто встречающиеся значение `2023-12-29 15:20:53` (встречается 621 раз).

### `target`

Создан датафрейм `target`, содержащий в себе данные о совершении покупок клиентами в целевой период. Он имеет 2 столбца и 49 849 строк. При этом столбцы имеют следующий характер:

- `client_id` — идентификатор клиента. Имеет тип `int64`;
- `target` — клиент совершил повторную покупку в целевом периоде. Имеет тип `int64`, а значения распределены от 0 до 1. При этом среднее значение составляет примерно 0.019, а медиана — 0.
- ## Построение моделей машинного обучения
- ### Подготовка данных

В качестве целевого признака была выбрана повторная покупка в целевой период (`target`), а в качестве числовых входных признаков: отфильтрованные и захэшированные категории товара (`category_id_hashed_filtered`), день недели действия с сообщением (`message_dayofweek`), разница во времени между отправкой сообщения и покупкой (`message_to_purchase_delay`), дата первой покупки (`first_purchase`), количество отправленных сообщений клиенту (`total_messages_sent`), доля открытых сообщений (`open_rate`), доля email-писем (`email_share`).

Так как в тренировочной выборке наблюдался огромный дисбаланс категорий целевого признака (в пользу не повторных покупок), а данных немного, то было решено устранить дисбаланс с помощью оверсэмплинга `SMOTE`. В валидационной и тестовой выборке дисбаланс сохранился для приближения к реальным данным.

В итоге, получились следующие выборки:

- тренировочная выборка: входные признаки имеют 721 600 строк и 7 столбцов (`X_train`), а целевой — 721 600 строк (`y_train`);
- валидационная выборка: входные признаки имеют 62 516 строк и 7 столбцов (`X_val`), а целевой — 62 516 строк (`y_val`);
- тестовая выборка: входные признаки имеют 62 516 строк и 7 столбцов (`X_test`), а целевой — 62 516 строк (`y_val`).

### Подбор моделей и их гиперпараметров

Для подготовки данных простым моделям были выбраны следующие методы:

- масштабирование: `StandardScaler`, `MinMaxScaler` и `RobustScaler`;
- кодирование: `OneHotEncoder`, `TargetEncoder`.

Для задачи классификации было выбрано 3 простых модели машинного обучения:

- k-ближайших соседей с гиперпараметрами: кол-во соседей от 5 до 30 (`n_neighbors`), равные (`uniform`) и обратные (`distance`) веса (`weights`);
- дерево решений с гиперпараметрами: максимальная глубина дерева от 2 до 20 (`max_depth`), минимальное кол-во объектов в узле от 2 до 20 (`min_samples_split`), минимальное кол-во объектов в листе от 1 до 10 (`min_samples_leaf`);
- случайный лес с гиперпараметрами: кол-во деревьев от 50 до 500 (`n_estimators`), максимальная глубина дерева от 2 до 20 (`max_depth`), минимальное кол-во объектов в узле от 2 до 20 (`min_samples_split`), минимальное кол-во объектов в листе от 1 до 10 (`min_samples_leaf`).

Гиперпараметры для градиентного бустинга `LightGBM`:

- оптимизация для бинарной классификации (`objective`);
- максимальное кол-во листьев в дереве: от 10 до 80 (`num_leaves`);
- минимальное кол-во объектов в листе: от 5 до 50 (`min_child_samples`);
- максимальная глубина дерева: от 3 до 10 (`max_depth`);
- кол-во деревьев: от 100 до 300 (`n_estimators`);
- шаг градиентного спуска: от 0.01 до 0.1 (`learning_rate`);
- L1-регуляризация: от 0.001 до 0.1 (`reg_alpha`);
- L2-регуляризация: от 0.001 до 0.1 (`reg_lambda`)
- оптимизация GPU (`task_type`).

Гиперпараметры для градиентного бустинга `CatBoost`:

- максимальная глубина дерева: от 3 до 10 (`depth`);
- кол-во деревьев: от 100 до 300 (`iterations`);
- шаг градиентного спуска: от 0.01 до 0.1 (`learning_rate`);
- L2-регуляризация: от 0.001 до 0.1 (`l2_leaf_reg`);
- быстрый бутстреп `Bernoulli` (`bootstrap_type`);
- 50-90% данных в каждом дереве (`subsample`);
- упрощенная дискретизация: от 32 до 128 (`border_count`);
- быстрое построение деревьев с помощью алгоритма `Lossguide` (`grow_policy`);
- остановка обучения, если нет улучшения за 50 итераций (`early_stopping_rounds`)
- оптимизация GPU (`task_type`).
### Обучение и валидация

Кросс-валидация с помощью `Optuna` показала, что среди всех простых моделей лучшей оказалась метод k-ближайших соседей со следующими гиперпараметрами:

- предобработка: кодирование `OneHotEncoder`;
- кол-во соседей: 28 (`n_neighbors`);
- веса: обратные (`distance`).
Метрика $ROC-AUC$ лучшей простой модели на валидационных данных составляет 0.995
## Лучшая модель

В качестве лучшей модели был выбран метод k-ближайших соседей, поскольку у него лучшая метрика $ROC-AUC$ на валидации (0.995), а также самые высокие значения по $Precision$ (89%) и $Recall$ (97%).

### Анализ важности признаков

С точки зрения лучшей модели и согласно графику важности SHAP в виде плотбара, входные признаки можно разделить на:

- **значимые**: дата первой покупки (`first_purchase`), отфильтрованные и захэшированные категории товара (`category_id_hashed_filtered`);
- **малозначимые**: количество отправленных сообщений клиенту (`total_messages_sent`);
- **незначимые**: разница во времени между отправкой сообщения и покупкой (`message_to_purchase_delay`), день недели действия с сообщением (`message_dayofweek`), доля email-писем (`email_share`), доля открытых сообщений (`open_rate`).

Согласно графику важности SHAP в виде beeswarm, явных разграничений принадлежности классу не наблюдается.
